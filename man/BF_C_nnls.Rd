% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bnxFortran-callable.R
\name{BF_C_nnls}
\alias{BF_C_nnls}
\title{Non-Negative Least Squares (NNLS) C Callable Interface}
\usage{
BF_C_nnls(A, MDA, M, N, B, X, RNORM, W, ZZ, INDEX, MODE, NSETP)
}
\arguments{
\item{A}{An double vector from e.g. \code{as.double()}. The input matrix
\code{A} as linear array. On entry contains the \code{M*N} matrix. On exit
contains the product matrix \code{Q*A}, where \code{Q} is an \code{M} by
\code{N} orthogonal matrix generated within the Fortran routine.}

\item{MDA}{An integer scalar from e.g. \code{as.integer()}. The first
dimensioning parameter for \code{A}, i.e. \code{nrow(A)}.}

\item{M}{An integer scalar from e.g. \code{as.integer()}. The number of rows
of \code{A}, i.e. \code{nrow(A)}.}

\item{N}{An integer scalar from e.g. \code{as.integer()}. The number of
columns of \code{A}, i.e. \code{ncol(A)}.}

\item{B}{An double vector from e.g. \code{as.double()}. An \code{length(N)}
vector. On entry contains the \code{N} vector. On exit contains \code{Q*B}.}

\item{X}{An double vector from e.g. \code{as.double()}. An \code{length(N)}
vector. On entry, need to be initialized with \code{0}. On exit contains
the solution.}

\item{RNORM}{An double scalar from e.g. \code{as.double()}. The Euclidean
norm of the residual array.}

\item{W}{An double vector from e.g. \code{as.double()}. An \code{length(N)}
vector as working space.}

\item{ZZ}{An double vector from e.g. \code{as.double()}. An \code{length(M)}
vector as working space.}

\item{INDEX}{An integer vector from e.g. \code{as.integer()}. An
\code{length(N)} vector.}

\item{MODE}{An integer scalar from e.g. \code{as.integer()}. The
success-failure flag as follows: 1 = solution computed successfully, 2 =
bad dimensions, 3 = iteration count exceeded.}

\item{NSETP}{An integer scalar from e.g. \code{as.integer()}. The number of
elements that are not bound at zero.}
}
\description{
Non-Negative Least Squares (NNLS) C Callable Interface
}
\details{
For details see: \code{\link[=nnls-interface]{.nnls}} and the
Fortran source \code{src/nnls.f}.
}
\section{Symbols}{
 \code{BF_C_nnls}
}

\section{Callable}{
 The callable function is defined in a C header file as
follows: \cr \emph{int(\emph{BF_C_nnls)(double \emph{A, int \emph{MDA, int \emph{M, int \emph{N,
double \emph{B, double \emph{X, double \emph{RNORM, double \emph{W, double \emph{ZZ, int \emph{INDEX, int
\emph{MODE, int \emph{NSETP);} \cr\cr Within the \code{R_init_...} function, the
callable function is imported via \cr \emph{BF_C_nnls = (int(})(double},
int}, int}, int}, double}, double}, double}, double}, double}, int}, int},
int})) R_GetCCallable("bnxFortran", "BF_C_nnls");}
}

\seealso{
Other callable: \code{\link{BF_C_intrpl}},
  \code{\link{BF_C_uvip3p}},
  \code{\link{bnxFortran-callable}}
}
\concept{callable}
\concept{nnls-callable}
